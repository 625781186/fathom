import base64
import mimetypes
import pathlib
import re

from click import argument, command, Path


BASE64_DATA_PATTERN = re.compile(r'(data:(?P<mime>[a-zA-Z0-9]+?/[a-zA-Z0-9\-.+]+?);(\s?charset=utf-8;)?base64,(?P<string>[a-zA-Z0-9+/=]+))')
# These are MIME types the `mimetypes` library doesn't recognize or gets wrong. Matches were found at:
# https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types
MIME_TYPE_TO_FILE_EXTENSION = {
    'application/font-woff': '.woff',
    'application/font-woff2': '.woff2',
    'application/vnd.ms-fontobject': '.eot',
    'font/opentype': '.otf',
    'font/ttf': '.ttf',
    'font/woff2': '.woff2',
    'image/jpeg': '.jpg',
    'image/webp': '.webp',
}


@command()
@argument('in_directory', type=Path(exists=True, file_okay=False))
def main(in_directory):
    """
    Extracts resources from the html pages in IN_DIRECTORY and stores them in a separate directory for Git-LFS storage.
    """
    for file in pathlib.Path(in_directory).iterdir():
        # TODO: How should we handle non-html files?
        if file.suffix != '.html':
            print(f'Skipping {file.name}; not an html file')
            continue
        extract_base64_data_from_html_page(file)


def extract_base64_data_from_html_page(file: pathlib.Path):
    """
    Extract all base64 data from the given html page and store the data in separate files.

    We do this by building a new html string using the non-base64 data pieces from the original file and the
    filenames we will generate for each of the base64 data strings.

    Base64 data is found with regex matching. Each data string is decoded and saved as a separate file.
    """
    with file.open(encoding='utf-8') as fp:
        html = fp.read()

    # Make the subresources directory
    subresources_directory = file.parent / f'{file.stem}_resources'
    subresources_directory.mkdir(exist_ok=True)

    offset = 0
    new_html = ''

    filename_counter = 0
    # A cache for elements that are repeated (e.g. icons)
    saved_strings = {}

    base64_data_matches = BASE64_DATA_PATTERN.finditer(html)
    for match in base64_data_matches:
        # Add the content before the base64 data
        new_html += html[offset:match.start(1)]

        base64_string = match.group('string')

        # Check to see if we have already encountered this base64 string
        file_path = saved_strings.get(base64_string, None)
        if file_path is None:
            mime_type = match.group('mime')
            filename_counter += 1
            filename = generate_filename(mime_type, str(filename_counter))
            binary_data = decode_base64_string_to_binary(base64_string)
            file_path = subresources_directory / filename
            save_binary_data(binary_data, file_path)
            # TODO: Is there a better format than the strings to use for caching?
            saved_strings[base64_string] = file_path

        # "Replace" the old base64 data with the relative path to the newly created file
        new_html += file_path.relative_to(file.parent).as_posix()

        # Move our offset to the end of the old base64 data
        offset = match.end(1)

    # Add the remainder of the content
    new_html += html[offset:]

    with (file.parent / f'extracted_{file.name}').open('w', encoding='utf-8') as fp:
        fp.write(new_html)


def decode_base64_string_to_binary(base64_string: str) -> bytes:
    """
    Decodes a string containing base64 data generated by Freeze-dry into bytes and returns it.

    Freeze-dry generates strings of the form: 'data:[some_mime_type];base64,[the_actual_base64_string]'
    """
    return base64.b64decode(base64_string)


def generate_filename(mime_type: str, filename: str) -> str:
    """
    Creates a filename to use for saving the base64 data with the appropriate file extension.

    We can't necessarily get an appropriate filename from the html the base64 data comes from, so we don't
    even try. Instead we just an incrementing counter to ensure unique filenames.

    The appropriate extension comes from mapping the MIME type contained in the base64 data to an extension.
    """
    # `mimetypes` gets some extensions wrong (e.g. image/jpeg -> .jpe) and doesn't
    # work for some MIME types that freeze-dry gives so use our own mapping first
    # TODO: This still feels a little fragile
    try:
        extension = MIME_TYPE_TO_FILE_EXTENSION[mime_type]
    except KeyError:
        extension = mimetypes.guess_extension(mime_type, strict=True)
    return f'{filename}{extension}'


def save_binary_data(binary_data: bytes, filepath: pathlib.Path):
    """Writes the given binary data to the given filepath."""
    with filepath.open('wb') as file:
        file.write(binary_data)


if __name__ == '__main__':
    main()
